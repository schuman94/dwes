...........
....PHP....
...........

STRING
"" -> interpreta las secuencias de escape y las variables.
'' -> no interpreta.
Existiendo $h y $hola: "{$h}ola" consigue interpolar $h 
$c[0] indexa bytes en vez de posiciones. Hay carácteres que ocupan 2 bytes.
mb_strlen() devuelve la longitud de una cadena.
trim(), ltrim() y rtrim() elimina espacios.
str_repeat("cadena", 5)
mb_strpos("cadena", "d") devuelve la posicion de la primera ocurrencia de la substring.
mb_substr($c, 4, 1) se usa en vez de indexar con $c[]

...................................
Secuencias heredoc y nowdoc
...................................
$c = <<<EOT
asfjafjàwdeifjawefjaefjawedifj

weFJNAOWIFJPWJEOWEFWEIFJEWO
asdasd  	$x	dfdasgdfg \n
EOT;
...................................
<<<'EOT' indica que no interpola cadenas ni expande variables (nowdoc)
.........................................................................


ARRAYS
unset() elimina variables o elementos de un array
$array[] = 'a' añade un nuevo elemento al array en la siguiente posición con el indice siguiente al mas grande que se ha usado.
isset() comprueba si una variable o un elemento del array existe o es null.
array_key_exists() devuelve true si la clave existe en ese array.
array_search('a', $a) en un array devuelve la primera clave que contenga el valor indicado.
asort() ordena por valor un array y devuelve true.
count() te cuenta el numero de elementos del array.
empty() devuelve true si el array está vacio. Tambien se usa para cadenas pero detecta la cadena "0" como vacia tambien.
print_r() imprime un array que tiene dentro otros arrays.

CONSTANTES
define('PI', 3.14) (Antiguo)
const PI = 3.14   (Nuevo)
Preguntar si una variable está definida: defined('PI')

COMPROBACINES DE TIPOS
gettype() devuelve una cadena con el tipo de la expresión.
is_*() donde * es el nombre del tipo, pregunta si la expresion es de ese tipo.
var_dump() vuelca (no devuelve) a la salida el valor y el tipo de la expresion.
is_null()
is_numeric() util para que nos devuelva true si lo que hay dentro es una cadena pero en realidad es un numero.
ctype_*() comprueba si la cadena está compuesta por un tipo de caracteres (digitos, alfanumericos, alfabeticos, mayusculas, etc)

CONVERSIONES
(int) "4" => 4
intval() boolval() floatval() strval()

COMPARACIONES
?? es el coalesce de sql. null ?? 5 devuelve 5 (el primero que no sea nulo)
<=> (nave espacial) devuelve numero mayor que 0, menor o igual dependiendo de las expresiones de ambos lados.
== comparacion normal, pero === compara el tipo sin hacer conversion implicita.
$a ? $a : $b (operador ternario)  Hay una simplificación (operador elvis) $a ?: $b


Crear servidor con php
php -S 0.0.0.0:8000
Podemos añadirle la opcion -t para indicar el documentroot, sino, es la carpeta actual.

git config --global user.name ""
git config --global user.email ""

implode('-', [1,2,3,4]) Te devuelve una cadena de todos los elementos del array separados en este caso por un guion.
explode('&', 'x=5&y=7') Te devuelve un array formado por elementos de la cadena que han sido separados en este caso por un &.

$_GET es un array que contiene clave (cadena) y valor (cadena) de los parametros de la petición get.
$_SERVER es un array que contiene bastante información util.

<?php echo expresion ?> es igual que <?= expresion ?>

foreach (array as [$k =>] $v) {}

ESTRUCTURAS DE CONTROL ALTERNATIVAS
while(condicion):
	...
endwhile;

__________________________

for(expe1;expr2;expr3):
	...
endfor;

__________________________

foreach (array as $v):
	...
endforeach;

_________________________

if (condicion):
	...
else:
	...
elseif (condicion):
	...
endif;

PLANTILLAS
De esta forma separamos el backend del frontend
<?php if (isset($_GET['y'])): ?>
	<p>El valor del parametro x es <?= $_GET['x'] ?></p>
<?php endif ?>


Crear repositorio en github desde terminal:
gh repo create nombre
Hay que instalar cli/cli de github.

Extensiones necesarias:
PHP Intelephense

in_array(x,y) comprueba si x está en el array y.

Definir funcion:
function prueba($par1, $par2)
{
	return
}
En php el paso de argumentos es por valor. Cuando tu le metes una cadena a una funcion, 
luego no estas usando esa cadena sino una nueva con su mismo valor.
Esto no pasaba en python ni java, alli el paso de argumentos es por referencia cuando son objetos, 
si son valores primitivos si son por valor. En php las cadenas son tipos primitivos, los objetos si se
pasan por referencia.

En php podemos obligar a que el paso de parametros sea por referencia usando el &:
funcion prueba(&$x) 
Por ejemplo, los arrays se pasan por valor, pero si queremos modificar 
el propio array desde dentro de la funcion y no a la copia, hay que obligarlo a que se pase por referencia.

global $g => declarar una funcion global dentro de una funcion (no se recomienda hacerlo).

Variables superglobales: variables globales que no hace falta declarar como globales, como $_GET

DECLARACIÓN DE FUNCIONES:
function nombre(string $x, string $y): string 
No es necesario pero puedes declarar los tipos de los parametros y del retorno
(recuerda que aun así hay tipado debil, no es neceasrio que la funcion reciba el tipo exacto)
En el caso de que la funcion pueda devolver null aparte de String, se trata de un valor de tipo nullable
Se representa con el ?: function nombre(string $x, string $y): ?string
Si una funcion no devuelve nada se puede indicar con un void
Para indicar que un parametro o valor de retorno puede tener mas de un tipo: int|float
function nombre(string|int $x, string $y): int|float|null


Comentarios de documentacion (documentar funciones):
/**
* @param string		$par	El nombre del parametro 
* @param array		$array	El array de errores
* @return string|null		El valor del parametro o null si no es un numero
*/
Con el plugin phpdoc comment puedes documentar: f1 -> add documentation


Cargar un fichero php en una plantilla:
<?php
require 'fichero.php';


<form action="" method="GET">    Cuando no indicas el valor del action significa que es el propio archivo.

isset($x, $y, $z) comprueba si una variable o varias existen y no son nulas.



FECHAS Y HORAS:
DateTime
DateTimeZone
DateTimeInmutable
DateInterval
DatePeriod
DateTimeInterface

$dti = new DateTimeInmutable(); Los parentesis no son necesarios si no hay parametros, pero es mejor ponerlos.

Acceder a una propiedad("atributos") o metodo de un objeto: $dti->format(php:d-m-Y')

Formato ISO: 'P1D'  (1 día)  'P1Y4M' (1 año y 4 meses) Son parámetros para el objeto DateInterval.


Triple igual (===) para comparar objetos significa si los objetos son el mismo (su identidad), no que simplemente
sean iguales, osea con mismos atributos y demás (==)

Las constantes quedan guardadas en la propia clase, no en una instancia del objeto. Para acceder a una:
DateTime::ATOM    Los "::" son el operador de resolucion de ambito.

El operador =& para objetos $x =& $y
No crea una nueva variable que apunte al mismo objeto, sino que la ligadura de $x apunta a la misma variable que $y.
Entonces, si ahora $x = new Object(), ahora $y tambien apunta a ese nuevo objeto.

Con los operadoes .= podemos concatenar por atras a una variable. $ .= "gsogf"

operador clone: hace copia superficial del objeto. $v = clone $w 

$w instanceof DateTime   (devuelve true o false)

la funcion checkdate() valida una fecha 

$fecha = explode('-', $val);  devuelve un array donde sus elementos son strings resultantes de cortar por el separador '-'
Incluso podemos asignarlos a la vez: [$a, $m, $d] = $fecha; 

array_map(funcion, array) aplica una funcion a todos los elementos de un array, devolviendo un array nuevo.
El primer parametro es una cadena con el nombre de la funcion: 'trim' por ejemplo.
El segundo parametro es el array.

extract() es una función que recibe un array y crea variables, y si ya existian, les cambia el valor:
extract(['x' => 4, 'y' => 7]);
La funcion contraria es compact(), recibe cadenas con el nombre de las variables y devuelve el array.


funcion array_diff_key() devuelve un array con la diferencia entre dos arrays que reciba como parametros.
Se utilizan las claves para comparar, no lo valores.
Si utilizas esta funcion para comparar los dos arrays, primero poniendo uno el primero y luego alreves, puedes
detectar si ambos arrays tienen exactamente las mismas claves.

array_intersect_key() hace la intersección, aqui da igual cual pongas primero, y no tienes que ponerlo dos veces.
Devuelve un array con los elementos que comparten ambos arrays, y, OJO, el valor que le da a la clave es el del primerr array.


EXCEPCIONES
Errores y excepciones (ambos implementan la interfaz throwable)
Al capturar errores con catch puedes incluir varios entre parentesis separando con un |

Si en el codigo ponemos: declare(strict_types=1) arriba del todo al abrir la etiqueta php, ya da error si le pasamos
un parametro de un tipo diferente al que pide una funcion, no se hace conversion implicita (solo en llamadas a funciones).
Hay que ponerlo en el script que llama a la funcion, no el que la crea. Y arriba del todo, en la primera linea:
<?php declare(strict_types=1) ?>


Instalar postgresql
sudo apt install postgresql
sudo -u postgres createdb prueba
sudo -u postgres createuser -P prueba
pqsl -h localhost -U prueba -d prueba

Una vez tenemos un fichero con la creacion de la tabla:
psql -h localhost -U prueba -d prueba < prueba.sql

$pdo = new PDO('pgsql:host=localhost;dbname=prueba', 'prueba', 'prueba');
$sent = $pdo->query('SELECT * FROM depart');
$filas = $sent->fetchAll(); (No se utiliza porque almacena todas las filas y eso es una locura)
$fila = $sent->fetch(); Recogemos una fila (es como un next).
Mejor usar el foreach:
foreach ($sent as $fila) {
	...	
}
Configurar postgres /etc/postgres/14/main/postgresql.conf
#intervalstyle = 'iso_8691' (linea 695)
timezone = 'UTC' (linea 696)

(linea 709)
# These settings are initialized by initdb, but they can be changed.
lc_messages = 'en_US.UTF-8'			# locale for system error message
					# strings
lc_monetary = 'en_US.UTF-8'			# locale for monetary formatting
lc_numeric = 'en_US.UTF-8'			# locale for number formatting
lc_time = 'en_US.UTF-8'				# locale for time formatting

# default configuration for text search
default_text_search_config = 'pg_catalog.english'


Luego de modfiicar:
sudo systemctl restart postgresql.service



Cuando hacemos una consulta que devuelve un valor, osea una fila y una columna, como por ejemplo con la funcion count(*) from emple:
usamos $sent->fetchColumn(); y lo podemos guardar en una variable, ya solo es un dato, no es un array.

fetchColumn es como el fetch, pero devuelve el valor de la columna que indiques en vez de un array de toda la fila.

Para las consultas where, podemos usar LIKE O ILIKE para que encontremos por ejemplo manolo, poniendo solo man.
where nombre ilike '%$nombre%'  Los tanto porciento son como los asteriscos, cualquier cadena antes y despues de nombre.


implode une elementos de un array en un string

header('Location: index.php');  Con esto redireccionamos.

return o exit(0); Termina la ejecución de la funcion.

output-buffering (parametro de configuracion del buffer) en: /etc/php/8.0/cli/php.ini 

Existen varias funciones de php para filtrar y ahorrarnos código:
filter_input(INPUT_POST, 'nombre'); sustituye al codigo que teniamos con el isset() del $_POST

ctype_digit("cadena") devuelve true si todos los caracteres son dígitos.

fetch(PDO::FETCH_ASSOC) solo devuelve el array con las asociaciones, no por indices